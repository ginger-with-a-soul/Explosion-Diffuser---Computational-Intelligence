# eXplosion Diffuser

## Uvod:
- Problem koji rešavamo zasnovan je na **izazivanju kombinatorne eksplozije** prilikom generisanja varijacija sa ponavljanjem, i uspešnoj pretrazi kroz prostor svih generisanih varijacija (odatle ime eXplosion Diffuser).
- Korisnik može sam da izabere **dužinu** varijacije a ona **ne može biti veća od 21 karaktera**. Ovo ograničenje stavljeno je iz praktičnih razloga jer UI deo postaje glomazan ako stavimo veći broj karaktera ali se ova zabrana lako može ukloniti. Nakon toga, korisnik može da izabere broj različitih simbola koje varijacija može da ima. **Broj simbola ograničen je na 36** - 26 slova engleskog alfabeta i brojevi [0, 9]. Ukupan broj varijacija može se izračunati po formuli `broj_simbola^dužina_varijacije` i ako se radi o najvećem broju varijacija koje program može da pretražujem, to je 36^21, odnosno **4.81229803398×10^32** što je više od broja bakterijskih ćelija na celom svetu kojih ima oko 100 puta manje. Kada korisnik izabere, na primer, da će koristiti 10 simbola, to znači da će u obzir dolaziti {a, b, c, d, e, f, g, h, i, j} jer su simboli leksikografski poređani tako da prvo idu slova a na kraju brojevi. Nakon izbora dužine varijacije i veličine skupa simbola koji mogu biti korišćeni, korisnik može da izabere jedan od trenutnu dva implementirana algoritma (**Monte Karlo sa gradijentnim spustom trenutno nije implementiran**).
- Ovaj problem izabrao sam razmišljajući o igri *Skočko* iz popularnog TV kviza *Slagalica* gde se uz pomoć 5 različitih simbola generiše varijacija dužine 4. Igrač u svakom koraku pokušava da pogodi o kojoj varijaci se radi a sistem mu daje povratnu informaciju o tome koliko je blizu rešenju bio i tu informaciju može da koristi za navođenje svoje *pretrage*. Zanimalo me je koliko velike ulaze možemo da zadamo računaru i koliko on brzo sam može da nađe rešenja s obzirom na eksponencijalnost problema. Zanimljivo je da sam, u poodmakloj fazi razvoja projekta, shvatio da ova postavka problema deli osnovu i sa igrom *Slagalica* iz istoimenog TV kviza. Naime, tamo se koristi fiksan broj od 30 slova odnosno simbola koje reč može da koristi i maksimalne dužine je 12 (od 30 različitih simbola, u opticaju u jednoj partiji su tačno 12 izabranih uz mogućnost ponavljanja). Da bi kompjuter u Slagalici pronašao najdužu reč, on mora da ima pristup srpskom rečniku kako bi proverio da li je reč koju je pronašao validna. Ako bismo mi taj isti rečnik dali našem programu, on bi mogao da od datog skupa slova koji ima na raspolaganju generiše sve varijacije od tih slova dužine 12 (uz smanjenje dužine za po 1 svaki put kada ne uspe da nađe ni jednu validnu reč određene dužine) a zatim pretraži taj prostor varijacija i vidi da li je neka reč te dužine valjana uz pomoć rečnika. Vrlo lako naš program možemo da modifikujemo tako da efikasno rešava i taj problem.
- Nažalost nisam uspeo da nađem nijedan dokumentovan rad na ovu temu iako sam uveren da ih ima.

## Opis rešenja zadatog problema:
- Prvobitan plan bio je da implementiram 3 različita algoritma koja će rešavati ovaj problem ali na kraju sam morao da se odlučim za samo dve metode, za sad, s obzirom na to da je projekat ispao dosta zahtevniji nego ono čemu sam se nadao. Odlučio sam se da prvo implementiram egzaktni **brute-force** algoritam koji će uspešno rešavati probleme veličine oko 10 i skupa simbola veličine oko 7. Inspiraciju za ovaj algoritam dobio sam sa jednog od prethodnih kurseva sa druge godine - *Algoritmi i strukture podataka*. Samo algoritamsko rešenje prilično je jednostavno i jasno a najveći deo baze koda otišao je na uspostavljanje funkcionalnog UI dela programa i vizualizacije rešenje. Algoritam grube sile kasnije će biti korišćen kao mali benčmark efikasnosti drugih algoritama.
- Drugi algoritam koji sam implementirao jeste **Genetski algoritam sa simuliranim kaljenjem**. Priroda problema koji se rešava je takva da je samo **enkodiranje problema** na jeziku genetskog algoritma izuzetno prosto - svaki gen kodiran je jednim od 36 mogućih simbola a svaki simbol predstavljen je brojem od 1 do 36. Odlučio sam da ne koristim karakterske ili stringovske oznake već da naš pseudo-nasumično generisan problem kodiram **brojevima** od 1 do 36 i da sve varijacije generišem pomoću brojeva od 1 do 36, i u tom formatu poredim da li je trenutno generisana varijacija jednaka pseudo-nasumično generisanom problemu. Ovaj način poređenja je *prirodniji* računaru nego poređenje stringova i u praksi je kompleksnost i bolja nego da poredimo stringove (`O(dužina_varijacije)` u odnosu na `O(log(dužina_varijacije)`) jer je `logaritam(dužina_varijacije)` u stvari broj bitova potrebnih da se broj zapiše pa se onda porede bitovi umesto karakteri kao što je slučaj kod stringova. **Fitnes funkcija** implementirana je tako da koristi heš-mapu i favorizuje varijacije koje su bliže traženoj tako što gleda broj simbola koji su baš na pravim mestima i broj simbola koji treba da se iskoriste ali nisu na svom pravom mestu. Prosečno vreme računanja fitnes funkcije je 2 * O(dužina_varijacije) a za detaljno objašnjenje pogledati `create_problem_dict` funkciju kod implementacije genetskog algoritma. Još jedno **poboljšanje** u odnosu na *lenji* način implementacije odnosi se na **manjak sortiranja prilikom zamene generacija**. Umesto toga, održavanjem heap-a elitnih jedinki u svakom trenutku imamo informaciju o trenutnom najboljem rešenju. **Simulirano kaljenje** primenjujemo svaki put nakon kreiranja novih jedinki dece i to tako što svaki put pošaljemo najbolju jedinku, i u stilu simuliranog kaljenja pokušamo da je popravimo stohastičkim pristupom. Ova praksa se pokazala izuzetno efikasnom jer ne uzima previše procesorskog vremena a relativno često nas izvuče iz lokalnog optimuma. Poslednja tehnika koju sam implementirao odnosi se na **dinamičko menjanje stepena mutacije** u odnosu na trenutak poslednjeg poboljšanja najboljeg rešenja - ako je prošao određeni broj generacija a naše najbolje rešenje se nije poboljšalo, stepen mutacije će iterativno rasti sve dok ne dostigne 30%, u nadi da će nas ta dodatna eksploracija dovesti do novih gena i uvesti pozitivan diverzitet u naš genetski skup i time nas odglaviti iz lokalnog optimuma.

## Eksperimentalni rezultati primene algoritama:
- **Složenost brute-force algoritma** gde je n = broj_korišćenih_simbola a k = dužina_varijacije je `n^k` jer je potrebno jednu po jednu generisati sve varijacije. Upravo ova eksponencijalna složenost okida kombinatornu eksploziju.
- **Složenost genetskog algoritma** znatno je smanjena pažljivom upotrebom odgovarajućih struktura podataka, enkodiranja rešenja i dobrim struktuiranjem programa. Ako označimo: `x = broj_generacija`, `y = broj_jedinki_u_populaciji`, mi u svakoj generaciji generišemo y jedinki pa je složenost O(x * y). Složenost prolaska kroz jednu generaciju je:
	- `O(1)` aproksimativno za **turnirsku selekciju** ako veličina turnira nije prevelika.
	- `3 * O(dužina_jedinke)` za uniformni **operator ukrštanja** jer on prvo instancira dve nove jedinke i računa im fitnes koji je složenosti 2 * O(dužina_jedinke) a zatim prolazi kroz ove jedinke u isto vreme i vrši ukrštanje što je još O(dužina_jedinke).
	- `2 * O(dužina_jedinke)` za **operator mutacije**.
	- `temperatura_kaljenja * O(dužina_jedinke)` za **simulirano kaljenje**.
	- `6 * O(log(broj_elitnih_jedinki))` za održavanje **min heap-a elitnih jedinki** - ako se pojavi jedinka koja je bolja od najlošije jedinke, ona će u `O(log(broj_elitnih_jedinki))` vremenu biti ubačena u min heap a u istom vremenu će i najlošija jedinka biti izbačena iz heap-a, a pošto se ova provera vrši 3 puta u toku generacije, složenost dobija konstantan faktor 6 ispred.
- Kada sve sumiramo, **složenost ove implementacije genetskog algoritma jeste O(broj_generacija * (5 * dužina_jedinke + temperatura_kaljenja * O(dužina_jedinke) + 6 * O(log(broj_elitnih_jedinki))))**
- Testirao sam oba algoritma na različitim dužinama varijacije i različitom veličinom skupa dozvoljenih simbola, ali svaki test za oba rađen je nad istim problemom: recimo da trenutno testiramo za varijaciju veličine 10, broja dozvoljenih simbola 5, oba algoritma će biti testirana nad identičnim ulazom. Jedina razlika, doduše može biti i jeste značajna, je što će broj jedinku u jednoj populaciji kod genetskog algoritma, biti menjan shodno težini problema i biće dodat u tabeli u koloni za genetski algoritam kao broj u zagradi pored vremena izvršavanja. Svako vreme dobijeno je kao prosek 5 vremena izvršavanja na mom sistemu.<br><br>

| Dužina varijacije | Veličina skupa simbola |Ukupan broj varijacija| Brute-force | Genetski-SA |
|       :---:       |         :----:         |        :---:         |    :---:    |    :---:    |
| 5                 | 5                      | 3 125                | < 1 sec     | < 1 sec (1 jedinka) |
| 10                | 5                      | 9 765 625            |  ~ 7 sec    | < 1 sec (1 jedinka) |
| 10                | 7                      | 282 475 249          |  ~ 3.5 min  | < 1 sec (1 jedinka) |
| 10                | 8                      | 1.073 * e9           |  ~ 12 min   | ~ 1 sec (1 jedinka) |
| 15                | 15                     | 4.378 * e17          | > 1.5 days  | ~ 4.5 sec (50 jedinki)|
| 20                | 20                     | 1.048 * e26          | NOT WORTH IT | ~ 15.5 sec (150 jedinki) |
| 21                | 36                     | 4.812 * e32          | NOT WORTH IT | ~ 70 sec (500 jedinki) |

<br><br>
- Program je pisan u **Python-u verzija 3.8.5 64-bit**. **Ubuntu 20.04** je pokretao **Visual Studio Code** okruženje u kojem sam pisao i kasnije testirao program. Sva testiranja rađena su na **Intel(R) Core(TM)i5-6400U** procesoru koji ima 4 jezgra a svako radi na 2.4GHz brzini. Zbog ugrađenog **Global Interpreter Lock sistema (GIL)**, Python programi rade na samo jednom jezgru čak i kada su implementirani tredovi. Jedini način da se ovo zaobiđe jeste korišćenje Multiprocessing-a. Sva testiranja programa rađena su na jednom 2.4GHz jezgru jer nisam implamentirao multiprocessing. Multithreading sam implementirao kako bi zamena konteksta bila brža i tako omogućio da se pseudo-paralelno izvršava algoritam sa iscrtavanjem korisničkog interfejsa i vizualizacijom rada algoritma. Pre multithreading-a izvršavanje algoritma onemogućilo bi prihvatljivo osvežavanje UI-a i iscrtavanja.

## Zaključak:
- Imam utisak da nakon svakog novog projekta naučim toliko novih stvari, da kada se osvrnem na neke stare projekte postoji osećaj da ih je pisala potpuno druga osoba. Isti osećaj imam i nakon ovog projekta. Retrospektivno gledano, postoji gomila stvari koje bih sada drugačije uradio jer sam naučio za bolje zahvaljujući ovom projektu. Jedna od tih stvari odnosi se na **bočne efekte** tj. višak njih. Izgubio sam sate i sate pokušavajući da pronađem određene bagove koji najverovatnije ne bi ni postojali da sam pazio na uticaj bočnih efekata. Još jedna stvar koja mi se podjednako jasno ucrtala u glavu jeste koliko je važno da kod bude čitljiv. Imao sam na velike glavobolje jer nisam na vreme, i pažljivije odvajao celine koda jedne od drugih, iako sam to pokušao. Vrlo je teško predvideti razvoj baze koda i kako sve to treba da se uklopi kada se dođe do kraja projekta i imam osećaj da sam ja u tome omanuo. Dalji cilj za unapređenje svojih programerskih sposobnosti mi je da preko funkcionalnog programiranja naučim kako da pobegnem od bočnih efekata i da pročitam knjigu **Clean Code**.
- Dalji cilj za ovaj projekat mi je da popravim sve bagove za koje trenutno znam, implementiram Monte Karlo metodu sa gradijentnim spustom kao i vizualizaciju za isti, refaktorišem delove korisničkog interfejsa i dodam jasnu oznaku da se greška dogodila na korisničkom interfejsu i koji deo istog je izazvao grešku (loš unos parametra će polje koje nije validno obojiti crvenom bojom).

## Literatura:
1. [Genetsko programiranje - slajdovi sa predavanja dr. Aleksandra Kartelja](http://poincare.matf.bg.ac.rs/~kartelj/nastava/RI2020/06.Genetski.algoritmi.pdf)
2. [Choosing Mutation and Crossover Ratios for Genetic Algorithms—A Review with a New Dynamic Approach](https://www.mdpi.com/2078-2489/10/12/390/pdf)
3. [Generisanje kombinatornih objekata - Algoritmi i strukture podataka, beleske sa predavanja i vezbi - Filip Maric, Vesna Marinkovic, Mladen Nikolic](http://poincare.matf.bg.ac.rs/~filip/asp/09_pretraga.pdf)